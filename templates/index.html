<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Popsicle</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    
    /* Left nav button hover with tooltip via title attribute is added inline below */
    .nav-btn {
      transition: transform 0.2s ease, background-color 0.2s ease;
      cursor: pointer;
    }
    .nav-btn:hover {
      transform: scale(1.1);
      background-color: #1f2937;
    }
    
    /* Set default canvas cursor */
    canvas { cursor: grab; }
    
    #bottom-panel {
      transition: max-height 0.3s ease-in-out;
    }
    /* Layers panel header glass effect */
    #layers-header {
      position: sticky;
      top: 0;
      background: rgba(33,33,33,0.8);
      backdrop-filter: blur(8px);
      z-index: 10;
      padding: 0.5rem 1rem;
    }
    /* The overlay for the selected layer â€“ used for resizing and rotating */
    #resize-overlay {
      border: 2px dashed #10b981;
      position: absolute;
      pointer-events: none;
    }
    /* Resizing handles for all sides */
    .resize-handle {
      width: 12px;
      height: 12px;
      background: #10b981;
      position: absolute;
      border-radius: 50%;
      cursor: pointer;
      pointer-events: all;
    }
    .handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
    .handle-n { top: -6px; left: calc(50% - 6px); cursor: n-resize; }
    .handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
    .handle-e { top: calc(50% - 6px); right: -6px; cursor: e-resize; }
    .handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
    .handle-s { bottom: -6px; left: calc(50% - 6px); cursor: s-resize; }
    .handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }
    .handle-w { top: calc(50% - 6px); left: -6px; cursor: w-resize; }
    
    /* Rotate handle positioned above the top center */
    .rotate-handle {
      width: 12px;
      height: 12px;
      background: #f59e0b;
      position: absolute;
      left: calc(50% - 6px);
      top: -30px;
      border-radius: 50%;
      cursor: grab;
      pointer-events: all;
    }
  </style>
</head>
<body class="bg-[#0f0f0f] text-white font-['Inter'] flex flex-col h-screen overflow-hidden p-4">
  <!-- Navigation Panel with tooltips -->
  <nav class="fixed left-4 top-4 h-[calc(100vh-32px)] w-12 bg-[#212121] border border-neutral-800 flex flex-col items-center py-4 space-y-6 rounded-2xl overflow-visible">
    <button class="nav-btn" title="Layers" data-action="layers" onclick="handleNavAction('layers')">
      <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
      </svg>
    </button>

    <button class="nav-btn" title="Assets" data-action="assets" onclick="handleNavAction('assets')">
      <!-- Changed Assets SVG (using a photograph icon) -->
      <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7h18M3 7a2 2 0 012-2h3.5a2 2 0 011.79 1.11L12 10.25l1.71-3.14A2 2 0 0115.5 5H19a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z" />
      </svg>
    </button>

    <button class="nav-btn" title="Remove Background" data-action="removeBg" onclick="handleNavAction('removeBg')">
      <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
      </svg>
    </button>

    <button class="nav-btn" title="Download" data-action="download" onclick="handleNavAction('download')">
      <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
      </svg>
    </button>
  </nav>

  <!-- Main Content -->
  <div class="pl-20 pr-4 flex h-full">
    <!-- Canvas Container -->
    <div class="flex-1 relative overflow-hidden rounded-2xl bg-[#0f0f0f] border border-neutral-800">
      <canvas id="mainCanvas" class="w-full h-full"></canvas>
      <!-- Resizing overlay for selected image with multiple handles -->
      <div id="resize-overlay" class="hidden">
        <div class="resize-handle handle-nw" data-handle="nw"></div>
        <div class="resize-handle handle-n" data-handle="n"></div>
        <div class="resize-handle handle-ne" data-handle="ne"></div>
        <div class="resize-handle handle-e" data-handle="e"></div>
        <div class="resize-handle handle-se" data-handle="se"></div>
        <div class="resize-handle handle-s" data-handle="s"></div>
        <div class="resize-handle handle-sw" data-handle="sw"></div>
        <div class="resize-handle handle-w" data-handle="w"></div>
        <div class="rotate-handle" data-handle="rotate"></div>
      </div>
      <div class="absolute top-4 left-1/2 -translate-x-1/2 w-full max-w-3xl">
        <textarea 
          placeholder="Write a prompt" 
          rows="1"
          class="bg-[#212121] min-h-[56px] w-full px-6 py-4 pr-24 outline-none focus:ring-2 focus:ring-emerald-500 transition-all duration-300 placeholder:text-gray-400 resize-none overflow-hidden rounded-[28px] focus:rounded-3xl"
        ></textarea>
        <!-- Arrow button for prompt generation -->
        <div class="absolute top-1/2 right-4 -translate-y-1/2 group">
          <button id="prompt-arrow" class="relative inline-flex items-center justify-center p-px font-semibold leading-6 text-white bg-neutral-900 shadow-2xl cursor-pointer rounded-full shadow-emerald-900 transition-all duration-300 ease-in-out hover:scale-105 active:scale-95 hover:shadow-emerald-600 text-sm">
            <span class="absolute inset-0 rounded-full bg-gradient-to-r from-emerald-500 via-cyan-500 to-sky-600 p-[2px] opacity-0 transition-opacity duration-500 group-hover:opacity-100"></span>
            <span class="relative z-10 block p-2 rounded-full bg-neutral-950">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 transition-all duration-500 group-hover:translate-x-1 group-hover:text-emerald-300">
                <path d="M16.172 11l-5.364-5.364 1.414-1.414L20 12l-7.778 7.778-1.414-1.414L16.172 13H4v-2z"></path>
              </svg>
            </span>
          </button>
        </div>
      </div>
    </div>

    <!-- Right Panel -->
    <div id="right-panel" class="w-80 bg-[#212121] border-l border-neutral-800 h-full flex flex-col">
      <!-- Layers panel with fixed header and glass effect -->
      <div id="layers-panel" class="flex-1 overflow-y-auto no-scrollbar">
        <div id="layers-header" class="text-white font-medium text-lg">Layers</div>
        <div id="layers-list" class="space-y-3 p-2"></div>
      </div>
      <div id="bottom-panel" class="border-t border-neutral-800 overflow-hidden" style="max-height: 0;">
        <!-- Assets Panel with glass effect -->
        <div id="assets-panel" class="p-6 overflow-y-auto max-h-[400px] hidden no-scrollbar">
          <div class="sticky top-0 bg-[#212121]/80 backdrop-blur-lg z-10 pb-4">
            <h2 class="text-white font-medium text-lg mb-4">Assets</h2>
            <div class="border-2 border-dashed border-neutral-700 rounded-xl p-4 text-center hover:border-emerald-500 transition-colors">
              <input type="file" id="asset-upload" accept="image/*" multiple class="hidden" onchange="handleAssetUpload(event)">
              <button onclick="document.getElementById('asset-upload').click()" class="w-full">
                <!-- Changed assets icon (photograph icon) -->
                <svg xmlns="http://www.w3.org/2000/svg" class="w-8 h-8 mx-auto mb-2 text-neutral-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7h18M3 7a2 2 0 012-2h3.5a2 2 0 011.79 1.11L12 10.25l1.71-3.14A2 2 0 0115.5 5H19a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z" />
                </svg>
                <p class="text-sm text-neutral-400">Drop files here or click to upload</p>
              </button>
            </div>
          </div>
          <!-- Assets grid -->
          <div id="assets-grid" class="grid grid-cols-3 gap-3 mt-4"></div>
        </div>
        <div id="adjustments-panel" class="p-6 hidden">
          <h2 class="text-white font-medium text-lg mb-4">Adjustments</h2>
          <div class="space-y-4">
            <div class="space-y-2">
              <label class="text-sm text-neutral-400">Brightness</label>
              <input type="range" min="0" max="200" class="w-full accent-emerald-500">
            </div>
            <div class="space-y-2">
              <label class="text-sm text-neutral-400">Contrast</label>
              <input type="range" min="0" max="200" class="w-full accent-emerald-500">
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Canvas and context
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');

    let layers = [];
    let layerCounter = 0;
    let selectedLayer = null;

    let viewOffsetX = 0, viewOffsetY = 0, viewScale = 1;
    let isPanning = false, panStart = { x: 0, y: 0 };

    // For dragging a selected layer individually
    let draggingLayer = false;
    let layerDragStart = { x: 0, y: 0 };
    let initialLayerPos = { x: 0, y: 0 };

    // Active control for resizing/rotating (handles)
    let activeControl = null;

    // Set up canvas size based on container dimensions
    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      redrawCanvas();
      updateResizeOverlay();
    }
    window.addEventListener('resize', resizeCanvas);

    // Show/hide bottom panels
    function showBottomPanel(panelId) {
      document.getElementById('assets-panel').classList.add('hidden');
      document.getElementById('adjustments-panel').classList.add('hidden');
      const bottomPanel = document.getElementById('bottom-panel');
      if(panelId === 'assets' || panelId === 'adjustments'){
        document.getElementById(panelId + '-panel').classList.remove('hidden');
        bottomPanel.style.maxHeight = '400px';
      } else {
        bottomPanel.style.maxHeight = '0';
      }
    }

    // --- Layer dragging vs. canvas panning ---
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left - viewOffsetX) / viewScale;
      const mouseY = (e.clientY - rect.top - viewOffsetY) / viewScale;
      // If a layer is selected and the click is inside its bounding box, start dragging the layer.
      if(selectedLayer &&
         mouseX >= selectedLayer.x - (selectedLayer.image.width * selectedLayer.scale) / 2 &&
         mouseX <= selectedLayer.x + (selectedLayer.image.width * selectedLayer.scale) / 2 &&
         mouseY >= selectedLayer.y - (selectedLayer.image.height * selectedLayer.scale) / 2 &&
         mouseY <= selectedLayer.y + (selectedLayer.image.height * selectedLayer.scale) / 2) {
        draggingLayer = true;
        layerDragStart.x = e.clientX;
        layerDragStart.y = e.clientY;
        initialLayerPos.x = selectedLayer.x;
        initialLayerPos.y = selectedLayer.y;
        return;
      }
      // Otherwise, start panning the canvas and change cursor to indicate panning.
      isPanning = true;
      panStart.x = e.clientX;
      panStart.y = e.clientY;
      canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', (e) => {
      if (draggingLayer && selectedLayer) {
        const dx = (e.clientX - layerDragStart.x) / viewScale;
        const dy = (e.clientY - layerDragStart.y) / viewScale;
        selectedLayer.x = initialLayerPos.x + dx;
        selectedLayer.y = initialLayerPos.y + dy;
        redrawCanvas();
        updateResizeOverlay();
      } else if (isPanning) {
        const dx = e.clientX - panStart.x;
        const dy = e.clientY - panStart.y;
        viewOffsetX += dx;
        viewOffsetY += dy;
        panStart.x = e.clientX;
        panStart.y = e.clientY;
        redrawCanvas();
        updateResizeOverlay();
      }
    });

    canvas.addEventListener('mouseup', () => { 
      isPanning = false; 
      draggingLayer = false;
      canvas.style.cursor = 'grab';
    });
    canvas.addEventListener('mouseleave', () => { 
      isPanning = false; 
      draggingLayer = false;
      canvas.style.cursor = 'grab';
    });

    // Click on canvas selects a layer (if within bounds)
    canvas.addEventListener('click', (e) => {
      if(activeControl) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left - viewOffsetX) / viewScale;
      const y = (e.clientY - rect.top - viewOffsetY) / viewScale;
      selectedLayer = null;
      for (let i = layers.length - 1; i >= 0; i--) {
        const layer = layers[i];
        const halfW = (layer.image.width * layer.scale) / 2;
        const halfH = (layer.image.height * layer.scale) / 2;
        if (x >= layer.x - halfW && x <= layer.x + halfW &&
            y >= layer.y - halfH && y <= layer.y + halfH) {
          selectedLayer = layer;
          break;
        }
      }
      updateResizeOverlay();
    });

    // Redraw canvas
    function redrawCanvas() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(viewScale, 0, 0, viewScale, viewOffsetX, viewOffsetY);
      layers.forEach(layer => {
        if(layer.visible) {
          ctx.save();
          ctx.translate(layer.x, layer.y);
          ctx.rotate(layer.rotation);
          ctx.scale(layer.scale, layer.scale);
          ctx.drawImage(layer.image, -layer.image.width / 2, -layer.image.height / 2);
          ctx.restore();
        }
      });
    }

    // Utility: get layer center on screen
    function getLayerCenterOnScreen(layer) {
      const x = viewScale * layer.x + viewOffsetX;
      const y = viewScale * layer.y + viewOffsetY;
      return { x, y };
    }

    // Drag and drop events for canvas
    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
      canvas.style.border = '2px dashed #10b981';
    });
    canvas.addEventListener('dragleave', () => { canvas.style.border = 'none'; });
    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      canvas.style.border = 'none';
      if (e.dataTransfer.files.length > 0) {
        const file = e.dataTransfer.files[0];
        if (file) handleImageUpload(file);
      } else {
        const imgSrc = e.dataTransfer.getData('text/plain');
        if (imgSrc) {
          const img = new Image();
          img.onload = () => { addNewLayer(img); redrawCanvas(); };
          img.src = imgSrc;
        }
      }
    });

    // Handle image upload
    function handleImageUpload(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => { 
          addNewLayer(img); 
          redrawCanvas(); 
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // Add a new layer with scaling and offset (to avoid "gluing")
    function addNewLayer(img) {
      layerCounter++;
      let scale = 1;
      const maxWidth = canvas.width * 0.8;
      const maxHeight = canvas.height * 0.8;
      const widthRatio = maxWidth / img.width;
      const heightRatio = maxHeight / img.height;
      scale = Math.min(1, widthRatio, heightRatio);
      let centerX = (canvas.width / 2 - viewOffsetX) / viewScale;
      let centerY = (canvas.height / 2 - viewOffsetY) / viewScale;
      if (layers.length > 0) {
        const lastLayer = layers[layers.length - 1];
        centerX = lastLayer.x + 40;
        centerY = lastLayer.y + 40;
      }
      const layer = {
        id: layerCounter,
        image: img,
        visible: true,
        name: `Layer ${layerCounter}`,
        x: centerX,
        y: centerY,
        scale: scale,
        rotation: 0
      };
      layers.push(layer);
      updateLayersList();
    }

    function removeBackground() { 
      // Now handled via backend call in handleRemoveBg()
    }

    function downloadCanvas() {
      const link = document.createElement('a');
      link.download = 'design.png';
      link.href = canvas.toDataURL();
      link.click();
    }

    // Asset upload and creation
    function handleAssetUpload(event) {
      const files = event.target.files;
      const assetsGrid = document.getElementById('assets-grid');
      for (const file of files) {
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const assetElement = createAssetElement(e.target.result, file.name);
            assetsGrid.insertBefore(assetElement, assetsGrid.firstChild);
          };
          reader.readAsDataURL(file);
        }
      }
    }
    function createAssetElement(src, name) {
      const div = document.createElement('div');
      div.className = 'group relative bg-neutral-800/50 rounded-xl p-2 hover:bg-neutral-800 transition-colors cursor-move';
      div.draggable = true;
      div.innerHTML = `
        <img src="${src}" alt="${name}" class="w-full h-24 object-cover rounded-lg mb-2">
        <p class="text-xs text-neutral-400 truncate">${name}</p>
        <button onclick="deleteAsset(this)" class="absolute top-1 right-1 p-1 bg-black/50 rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      `;
      div.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', src); });
      return div;
    }
    function deleteAsset(button) { 
      button.closest('div').remove(); 
    }

    // Update layers list in the right panel
    function updateLayersList() {
      const layersList = document.getElementById('layers-list');
      layersList.innerHTML = '';
      // Iterate in reverse order so that top layers are listed first.
      [...layers].reverse().forEach(layer => {
        // Determine the toggle icon based on visibility:
        const toggleIcon = layer.visible
          ? `<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
               <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
               <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
             </svg>`
          : `<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
               <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.542-7a10.05 10.05 0 012.143-3.357M4.707 4.707l14.586 14.586" />
               <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.88 9.88a3 3 0 104.24 4.24" />
             </svg>`;
        // Create the layer element; clicking the element selects the layer.
        const layerElement = document.createElement('div');
        layerElement.className = 'bg-neutral-800/50 backdrop-blur-sm rounded-xl p-3 flex items-center justify-between group hover:bg-neutral-800 transition-colors cursor-pointer';
        layerElement.setAttribute('draggable', true);
        layerElement.setAttribute('onclick', `selectLayer(${layer.id})`);
        layerElement.innerHTML = `
          <div class="flex items-center gap-3">
            <div class="w-10 h-10 rounded-lg bg-neutral-700 flex items-center justify-center overflow-hidden">
              <img src="${layer.image.src}" class="w-full h-full object-cover">
            </div>
            <span class="text-sm text-neutral-200">${layer.name}</span>
          </div>
          <div class="flex gap-2">
            <button onclick="toggleLayerVisibility(${layer.id}); event.stopPropagation();" class="text-neutral-400 hover:text-white" title="Toggle Visibility">
              ${toggleIcon}
            </button>
            <button onclick="deleteLayer(${layer.id}); event.stopPropagation();" class="text-neutral-400 hover:text-white" title="Delete Layer">
              <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
              </svg>
            </button>
          </div>
        `;
        // Drag and drop events for reordering layers:
        layerElement.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', layer.id);
        });
        layerElement.addEventListener('dragover', (e) => { e.preventDefault(); });
        layerElement.addEventListener('drop', (e) => {
          e.preventDefault();
          const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
          reorderLayers(draggedId, layer.id);
        });
        layersList.appendChild(layerElement);
      });
    }
    function selectLayer(layerId) {
      selectedLayer = layers.find(l => l.id === layerId);
      updateResizeOverlay();
    }
    function toggleLayerVisibility(layerId) {
      const layer = layers.find(l => l.id === layerId);
      if(layer){
        layer.visible = !layer.visible;
        redrawCanvas();
        updateLayersList();
        updateResizeOverlay();
      }
    }
    function deleteLayer(layerId) {
      layers = layers.filter(l => l.id !== layerId);
      if(selectedLayer && selectedLayer.id === layerId){
        selectedLayer = null;
      }
      redrawCanvas();
      updateLayersList();
      updateResizeOverlay();
    }
    function reorderLayers(draggedId, targetId) {
      const draggedIndex = layers.findIndex(l => l.id === draggedId);
      const targetIndex = layers.findIndex(l => l.id === targetId);
      if(draggedIndex > -1 && targetIndex > -1){
        const [draggedLayer] = layers.splice(draggedIndex, 1);
        layers.splice(targetIndex, 0, draggedLayer);
        redrawCanvas();
        updateLayersList();
      }
    }

    // Update the resizing overlay position and size
    function updateResizeOverlay() {
      const overlay = document.getElementById('resize-overlay');
      if(!selectedLayer) { 
        overlay.classList.add('hidden');
        return; 
      }
      const centerX = viewScale * selectedLayer.x + viewOffsetX;
      const centerY = viewScale * selectedLayer.y + viewOffsetY;
      const width = viewScale * selectedLayer.image.width * selectedLayer.scale;
      const height = viewScale * selectedLayer.image.height * selectedLayer.scale;
      overlay.style.left = (centerX - width/2) + 'px';
      overlay.style.top = (centerY - height/2) + 'px';
      overlay.style.width = width + 'px';
      overlay.style.height = height + 'px';
      overlay.classList.remove('hidden');
    }

    // Handle mousedown on a resize or rotate handle
    function onHandleMouseDown(e) {
      e.stopPropagation();
      const handleType = e.target.getAttribute('data-handle');
      if(!selectedLayer) return;
      if(handleType === 'rotate') {
        activeControl = {
          type: 'rotate',
          initialMouse: { x: e.clientX, y: e.clientY },
          initialRotation: selectedLayer.rotation,
          center: getLayerCenterOnScreen(selectedLayer)
        };
      } else {
        activeControl = {
          type: 'resize',
          handle: handleType,
          initialMouse: { x: e.clientX, y: e.clientY },
          initialScale: selectedLayer.scale,
          center: getLayerCenterOnScreen(selectedLayer)
        };
        const dx = e.clientX - activeControl.center.x;
        const dy = e.clientY - activeControl.center.y;
        activeControl.initialDistance = Math.sqrt(dx*dx + dy*dy);
      }
    }
    // Attach mousedown events to all handles
    const handles = document.querySelectorAll('#resize-overlay [data-handle]');
    handles.forEach(handle => {
      handle.addEventListener('mousedown', onHandleMouseDown);
    });
    // Global mousemove for active control (resize/rotate)
    window.addEventListener('mousemove', (e) => {
      if(activeControl && selectedLayer) {
        if(activeControl.type === 'rotate') {
          const center = activeControl.center;
          const dx = e.clientX - center.x;
          const dy = e.clientY - center.y;
          const newAngle = Math.atan2(dy, dx);
          const initialDx = activeControl.initialMouse.x - center.x;
          const initialDy = activeControl.initialMouse.y - center.y;
          const initialAngle = Math.atan2(initialDy, initialDx);
          const delta = newAngle - initialAngle;
          selectedLayer.rotation = activeControl.initialRotation + delta;
        } else if(activeControl.type === 'resize') {
          const center = activeControl.center;
          const dx = e.clientX - center.x;
          const dy = e.clientY - center.y;
          const currentDistance = Math.sqrt(dx*dx + dy*dy);
          const factor = currentDistance / activeControl.initialDistance;
          selectedLayer.scale = activeControl.initialScale * factor;
        }
        redrawCanvas();
        updateResizeOverlay();
      }
    });
    window.addEventListener('mouseup', () => { activeControl = null; });

    // Auto-resizing textarea
    document.querySelector('textarea').addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = this.scrollHeight + 'px';
    });

    // ---------------- Backend integration functions ----------------

    document.querySelector('[data-action="removeBg"]').addEventListener('click', async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                // Show loading indicator
                document.body.style.cursor = 'wait';
                
                const response = await fetch('/remove-bg', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Background removal failed');
                }
                
                const blob = await response.blob();
                const img = new Image();
                img.onload = () => {
                    addNewLayer(img);
                    redrawCanvas();
                    
                    // Add to assets grid
                    const assetsGrid = document.getElementById('assets-grid');
                    const assetElement = createAssetElement(img.src, "Removed BG");
                    assetsGrid.insertBefore(assetElement, assetsGrid.firstChild);
                };
                img.src = URL.createObjectURL(blob);
                
            } catch (error) {
                console.error('Background removal failed:', error);
                alert('Background removal failed: ' + error.message);
            } finally {
                document.body.style.cursor = 'default';
            }
        };
        
        input.click();
    });

    // Handle prompt generation 
    document.getElementById('prompt-arrow').addEventListener('click', async () => {
        const prompt = document.querySelector('textarea').value.trim();
        if (!prompt) {
            alert('Please enter a prompt before generating an image.');
            return;
        }
        
        try {
            // Show loading indicator
            document.body.style.cursor = 'wait';
            
            const response = await fetch('/generate-image', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ prompt })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Image generation failed');
            }
            
            const data = await response.json();
            
            if (data.image) {
                const img = new Image();
                img.onload = () => {
                    addNewLayer(img);
                    redrawCanvas();
                    
                    // Add to assets grid
                    const assetsGrid = document.getElementById('assets-grid');
                    const assetElement = createAssetElement(img.src, `Generated: ${prompt.substring(0, 20)}...`);
                    assetsGrid.insertBefore(assetElement, assetsGrid.firstChild);
                };
                img.src = "data:image/png;base64," + data.image;
            } else {
                throw new Error('No image data received');
            }
            
        } catch (error) {
            console.error('Image generation failed:', error);
            alert('Image generation failed: ' + error.message);
        } finally {
            document.body.style.cursor = 'default';
        }
    });


    // Helper to add an asset to the assets grid
    function addAsset(img, name) {
      const assetsGrid = document.getElementById('assets-grid');
      const assetElement = createAssetElement(img.src, name || "Asset");
      assetsGrid.insertBefore(assetElement, assetsGrid.firstChild);
    }

    // ---------------- Navigation actions ----------------
    function handleNavAction(action) {
      switch(action) {
        case 'upload': /* handle upload */; break;
        case 'layers': showBottomPanel(''); break;
        case 'assets': showBottomPanel('assets'); break;
        case 'adjustments': showBottomPanel('adjustments'); break;
        case 'removeBg': handleRemoveBg(); break;
        case 'download': downloadCanvas(); break;
      }
    }

    // Initialize on window load
    window.onload = () => {
      updateLayersList();
      resizeCanvas();
    };
    
    // Handle background removal button
    document.querySelector('[data-action="removeBg"]').addEventListener('click', async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/remove-bg', {
                    method: 'POST',
                    body: formData
                });
                const blob = await response.blob();
                addImageToCanvas(blob);
                addToAssets(blob);
            } catch (error) {
                console.error('Background removal failed:', error);
            }
        };
        
        input.click();
    });

    // Handle prompt generation
    document.querySelector('.prompt-button').addEventListener('click', async () => {
        const prompt = document.querySelector('textarea').value;
        
        try {
            const response = await fetch('/generate-image', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ prompt })
            });
            
            const blob = await response.blob();
            addImageToCanvas(blob);
            addToAssets(blob);
        } catch (error) {
            console.error('Image generation failed:', error);
        }
    });

    // Helper functions
    function addImageToCanvas(blob) {
        const img = new Image();
        img.src = URL.createObjectURL(blob);
        img.onload = () => {
            // Add to canvas implementation
            const layer = {
                image: img,
                x: canvas.width/2,
                y: canvas.height/2,
                scale: 1
            };
            layers.push(layer);
            redrawCanvas();
        };
    }

    function addToAssets(blob) {
        const asset = {
            id: assets.length,
            preview: URL.createObjectURL(blob)
        };
        assets.push(asset);
        updateAssetsGrid();
    }
  </script>
</body>
</html>
    